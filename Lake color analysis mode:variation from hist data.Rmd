---
title: "Lake color analysis mode/variation"
author: "Xiao Yang"
date: "5/19/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

require(tidyverse)
require(sf) 

chroma <- function(R, G, B) {
  require(colorscience)

  Xi <- 2.7689*R + 1.7517*G + 1.1302*B
  Yi <- 1.0000*R + 4.5907*G + 0.0601*B
  Zi <- 0.0565*G + 5.5943*B

  x <-  Xi / (Xi + Yi +  Zi)
  y <-  Yi / (Xi + Yi +  Zi)
  z <-  Zi / (Xi + Yi +  Zi)

  alpha <- atan2( (x - 0.33), (y - 0.33)) * 180/pi

  cie <- colorscience::cccie31 %>%
    mutate(a = atan2( (x - 0.33), (y - 0.33)) * 180/pi) %>%
    dplyr::filter(wlnm <= 700) %>%
    dplyr::filter(wlnm >= 380) %>%
    select(a, wlnm) %>%
    arrange(a)

  wl <- cie[as.vector(sapply(alpha,function(x) which.min(abs(x - cie$a)))), 'wlnm']

  return(wl)
}

Adjust = function (myColor, Factor, Gamma, IntensityMax = 1) {
    if (length(myColor) == 1) {
        if (myColor == 0) {
          return(0)}
        else {
          return(IntensityMax * (myColor * Factor)^Gamma)
          }
    }
    else {
        w <- which(myColor != 0)
        myColor[w] <- IntensityMax * (myColor[w] * Factor[w])^Gamma
        return(myColor)
    }
}

heuristic.wlnm2RGB_modified = function (wavelength, Gamma = 0.8, IntensityMax = 1) {
    if (IntensityMax < 0) 
        IntensityMax <- 0
    if (IntensityMax > 1) 
        IntensityMax <- 1
    wavelength <- round(wavelength)
    Red <- Green <- Blue <- factorL <- rep(0, length(wavelength))
    w <- which(wavelength %in% 380:439)
    if (length(w) > 0) {
        Red[w] <- -(wavelength[w] - 440)/(440 - 380)
        Green[w] <- 0
        Blue[w] <- 1
    }
    w <- which(wavelength %in% 440:489)
    if (length(w) > 0) {
        Red[w] <- 0
        Green[w] <- (wavelength[w] - 440)/(490 - 440)
        Blue[w] <- 1
    }
    w <- which(wavelength %in% 490:509)
    if (length(w) > 0) {
        Red[w] <- 0
        Green[w] <- 1
        Blue[w] <- -(wavelength[w] - 510)/(510 - 490)
    }
    w <- which(wavelength %in% 510:579)
    if (length(w) > 0) {
        Red[w] <- (wavelength[w] - 510)/(580 - 510)
        Green[w] <- 1
        Blue[w] <- 0
    }
    w <- which(wavelength %in% 580:644)
    if (length(w) > 0) {
        Red[w] <- 1
        Green[w] <- -(wavelength[w] - 645)/(645 - 580)
        Blue[w] <- 0
    }
    w <- which(wavelength %in% 645:780)
    if (length(w) > 0) {
        Red[w] <- 1
        Green[w] <- 0
        Blue[w] <- 0
    }
    w <- which(wavelength %in% 380:419)
    if (length(w) > 0) 
        factorL[w] <- 0.3 + 0.7 * (wavelength[w] - 380)/(420 - 
            380)
    w <- which(wavelength %in% 420:700)
    if (length(w) > 0) 
        factorL[w] <- 1
    w <- which(wavelength %in% 701:780)
    if (length(w) > 0) 
        factorL[w] <- 0.3 + 0.7 * (780 - wavelength[w])/(780 - 
            700)
    R <- Adjust(Red, factorL, Gamma, IntensityMax)
    G <- Adjust(Green, factorL, Gamma, IntensityMax)
    B <- Adjust(Blue, factorL, Gamma, IntensityMax)
    as_tibble(list(R = R, G = G, B = B)) %>% transmute(color = rgb(R, G, B))
}


unpackHist = function(histString, colNames) {
  # take histString as input (output from ee.Reducer.fixedHistogram() on GEE)
  # return a 2-column tibble: first column the value of the left break and second column is the count in the bin
  output = (histString %>% 
              str_remove_all(pattern = "\\[|\\]") %>% 
              str_split(pattern = ","))[[1]] %>% 
    as.numeric() %>% 
    matrix(ncol = 2, byrow = T) %>% 
    as_tibble() %>% 
    filter(V2 != 0) %>% 
    mutate(V2 = as.integer(V2))
  
  names(output) = colNames
  
  return(output)
}
```

## Overview
This script analyze lake color mode and standard deviation calculated from most recent 5 years of Landsat 8 data (SR, Collection 1 Tier 1, cloud <= 25, 2015-2020)


## import data

```{r}
require(stringr)
require(diptest)
## load lake data 
lakes = st_read("outputs/lake_samples_jida_05172020.shp")
lakes_meta = lakes %>% mutate(cd = st_centroid(geometry), clon = st_coordinates(cd)[, 1], clat = st_coordinates(cd)[, 2], area = lwgeom::st_geod_area(geometry)) %>% select(id, clon, clat, area) %>% st_drop_geometry()

version = "aa953bbd64158902fff621401f23b12f"

## why there are so many lakes having NA values?
read_csv(dir(path = "data/lake_color_hist_dp_aa953bbd64158902fff621401f23b12f/", full.names = T, pattern = "*.csv")[i]) %>% filter(is.na(s_mean)) %>% summary()

nFiles = length(dir(path = "data/lake_color_hist_dp_aa953bbd64158902fff621401f23b12f/", full.names = T, pattern = "*.csv"))


for (i in 1:nFiles) {
  
  print(paste0("File ", i, " started..."))
  
  datIn = read_csv(dir(path = "data/lake_color_hist_dp_aa953bbd64158902fff621401f23b12f/", full.names = T, pattern = "*.csv")[i]) %>% 
    na.omit()
  
  #
  datDw = datIn %>% filter(dw_count >= 10) %>% select(id, histgram = dw_histgram) %>% mutate(source = "dw")
  datDwLehmann = datIn %>% filter(dw_count >= 10) %>% select(id, histgram = dwLehmann_histgram) %>% mutate(source = "dwLehmann")
  datHue = datIn %>% filter(dw_count >= 10) %>% select(id, histgram = hue_histgram) %>% mutate(source = "hue")
  
  histMerged = bind_rows(datDw, datDwLehmann, datHue)
  
  thisHistUnpacked = histMerged %>% 
    group_by(id, source) %>% 
    do({
      dat = .
      unpackHist(dat$histgram[1], colNames = c("metric", "count"))
    }) %>% 
    ungroup()
  
  sourceIntervals = tibble(source = c("dw", "dwLehmann", "hue"), halfInterval = c(5, 5, 1 / 64) / 2)
  
  thisHistModeTest = thisHistUnpacked %>% 
    left_join(sourceIntervals, by = "source") %>% 
    mutate(metricMid = metric + halfInterval) %>% 
    group_by(id, source) %>% 
    do({
      dat = .
      unpackedCount = dat %>% 
        group_by(metric) %>% 
        do({
          datm = .
          tibble(metricUnpacked = rep(x = datm$metricMid[1], times = datm$count[1]))
          }) %>% 
        ungroup()
      
      values = unpackedCount %>% pull(metricUnpacked) # reconstructed values
      dip = values %>% dip.test()
      d = values %>% density()
      mode = d$x[which.max(d$y)][1]
      
      dip[1:3] %>% as_tibble() %>% mutate(mode_density = mode, bw = d$bw)
    }) %>% 
    ungroup()
  
  thisDatOut = datIn %>% 
    select(-hue_histgram, -dw_histgram, -dwLehmann_histgram) %>% 
    left_join(thisHistModeTest %>% select(id, source, p.value) %>% spread(key = source, value = p.value) %>% rename(dw.pv = dw, dwLehmann.pv = dwLehmann, hue.pv = hue), by = "id") %>% 
    left_join(thisHistModeTest %>% select(id, source, mode_density) %>% spread(key = source, value = mode_density) %>% rename(dw.mode = dw, dwLehmann.mode = dwLehmann, hue.mode = hue), by = "id")
  
  save(thisHistModeTest, thisDatOut, file = paste0("outputs/histUnpacked_", i, ".RData"))
  
  if (i == 1) {
    histModeTest = thisHistModeTest
    datOut = thisDatOut
    histUnpacked = thisHistUnpacked
  }
  if (i != 1) {
    histModeTest = histModeTest %>% bind_rows(thisHistModeTest)
    datOut = datOut %>% bind_rows(thisDatOut)
    histUnpacked = histUnpacked %>% bind_rows(thisHistUnpacked)
  }
}

save(histModeTest, datOut, histUnpacked, file = paste0("outputs/histUnpacked_", version, ".RData"))

load(paste0("outputs/histUnpacked_", version, ".RData"), verbose = T)


## plot some results

sampledIds = histModeTest %>% 
  filter(source == "dw"
         # nobs >= 25
         ) %>% 
  mutate(unimodal = p.value >= 0.05) %>% 
  group_by(unimodal) %>% 
  sample_n(1) %>% 
  ungroup()

histUnpacked %>% 
  right_join(sampledIds, by = c("id", "source")) %>% 
  ggplot() +
  geom_bar(aes(x = metric, y = count, fill = id), stat = "identity", width = 5, color = "white") +
  # geom_line(aes(x = metric, y = count, color = id)) +
  geom_vline(aes(xintercept = mode_density), color = "black") +
  facet_wrap(~unimodal, ncol = 1, scales = "free_y")

## inspect modes that are very different between density and hist approaches
datOut %>% 
  ggplot() + 
  geom_point(aes(x = dw_mode, y = dw.mode, color = dw.pv <= 0.01), pch = 1) +
  geom_abline(aes(slope = 1, intercept = 0, color = "1:1"))

datOut %>% 
  ggplot() + 
  geom_point(aes(x = dwLehmann.mode, y = dw.mode, color = dw.pv <= 0.01), pch = 1, alpha = 0.1) +
  geom_abline(aes(slope = 1, intercept = 0, color = "1:1")) +
  scale_x_continuous(limits = c(475, 600)) +
  scale_y_continuous(limits = c(475, 600))

datOut %>% 
  ggplot() + 
  geom_point(aes(x = dwLehmann_mode, y = dw_mode, color = dw.pv <= 0.01), pch = 1, alpha = 0.1) +
  geom_abline(aes(slope = 1, intercept = 0, color = "1:1")) +
  scale_x_continuous(limits = c(475, 600)) +
  scale_y_continuous(limits = c(475, 600))

datOut %>% 
  ggplot() + 
  geom_histogram(aes(x = dw.mode - dw_mode), binwidth = 2.5, color = "white") +
  scale_x_continuous(limits = c(-25, 25))


dat = datOut

dat %>% nrow()

print("how many centroids fall outside of the lake polygon?")
(dat %>% filter(is.na(dist2ShoreDp)) %>% select(id) %>% distinct %>% nrow()) / (dat %>% select(id) %>% distinct %>% nrow)

print("Where are the lakes with centroid outside its polygons?")
lake_id_null_ct_dist2Shore = dat %>% filter(is.na(dist2ShoreDp)) %>% select(id) %>% distinct
# lakes %>% right_join(lake_id_null_ct_dist2Shore, by = "id") %>% sample_frac(0.3) %>% st_as_sf %>% mapview::mapview()

print("how many lakes with centroid inside their polygons but still have NA values for the extracted hue/dw values?")
dat %>% filter(!is.na(dist2Shore), is.na(hue_mode)) %>% select(id) %>% distinct() %>% nrow()

dat = dat %>% na.omit()

dat %>% nrow()

dat = dat %>% 
  left_join(lakes_meta, by = "id")

save(dat, file = paste0("outputs/dat_", version, ".RData"))

dat %>% nrow()
dat %>% summary()
```

## Distribution of color

```{r}
print("How many lakes have hue_count less than 10?")
dat %>% filter(dw_count < 10) %>% select(id) %>% distinct() %>% nrow()

datFil = dat %>% 
  filter(dw_count >= 10)

datFil %>% nrow()

datFil %>% 
  gather(key = "variable", value = "mode", c(hue_mode, dw_mode, dwLehmann_mode, dw_count, dw.mode, dwLehmann.mode)) %>% 
  ggplot() +
  geom_density(aes(x = mode)) +
  facet_wrap(~variable, scales = "free")

```

### Summary stats

```{r}
## density plot
calc_hue_density = function(hue) {
  
  d = density(hue, n = 512)
  
  hue_density = tibble(hue = d$x, density = d$y) %>% 
    filter(hue >= 0, hue <= 1) %>% 
    mutate(rgb_color = hsv(h = hue, s = 1, v = 1))
  
  return(hue_density)
}
calc_dw_density = function(dw) {
  
  d = density(dw, n = 512)
  
  # dw_density = tibble(dw = d$x, density = d$y) %>% 
  #   # filter(hue >= 0, hue <= 1) %>% 
  #   group_by(dw, density) %>% 
  #   do({dw2rgb(.$dw[1])}) %>% 
  #   ungroup() %>% 
  #   rename(rgb_color = rgb) %>% 
  #   select(-R, -G, -B)
  
  dw_density = tibble(dw = d$x, density = d$y) %>% 
    # filter(hue >= 0, hue <= 1) %>% 
    bind_cols(heuristic.wlnm2RGB_modified(d$x)) %>% 
    rename(rgb_color = color)
  
  return(dw_density)
}

hue_density = calc_hue_density(dat$hue_mode)
dw_density = calc_dw_density(dat$dw_mode)
dwLehmann_density = calc_dw_density(dat$dwLehmann_mode)

combined = hue_density %>% rename(value = hue) %>% mutate(metric = "Mode(Hue)") %>% 
  bind_rows(dw_density %>% rename(value = dw) %>% mutate(metric = "Mode(Dominant wavelength) (nm)")) %>% 
  bind_rows(dwLehmann_density %>% rename(value = dw) %>% mutate(metric = "Mode(Dominant wavelength) (nm)/ Lehmann et al."))

all_lake_color = combined %>% 
  ggplot(aes(value, density)) + 
  geom_segment(aes(xend = value, yend = 0, color = rgb_color), alpha = 1) + 
  geom_line(lwd = 1) + 
  scale_color_identity() +
  # scale_x_continuous(limits = c(0, 1)) +
  labs(
    title = "Distribution of most frequent lake colors"
  ) +
  theme(
    panel.background = element_blank(),
    axis.title.y = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  ) +
  facet_wrap(~metric, scales = "free", ncol = 1)

all_lake_color

all_lake_color %>% ggsave(filename = paste0("figs/all_lake_color_dw_", version, ".png"), width = 6, height = 6)

## binned by hue_count

combined_grped = dat %>% 
  mutate(count_grp = cut(hue_count, breaks = quantile(dat$hue_count, probs = seq(0, 1, by = 0.2)), include.lowest = T, dig.lab = 1)) %>% 
  group_by(count_grp) %>% 
  do({
    datm = .
    hue_density = calc_hue_density(datm$hue_mode)
    dw_density = calc_dw_density(datm$dw_mode)
    
    hue_density %>% rename(value = hue) %>% mutate(metric = "Mode(Hue)") %>% 
      bind_rows(dw_density %>% rename(value = dw) %>% mutate(metric = "Mode(Dominant wavelength) (nm)"))
  }) %>% 
  ungroup()

all_lake_color_grouped_dw = combined_grped %>% 
  filter(metric == "Mode(Dominant wavelength) (nm)") %>% 
  ggplot(aes(value, density)) + 
  geom_segment(aes(xend = value, yend = 0, color = rgb_color), alpha = 1) + 
  geom_line(lwd = 1) + 
  scale_color_identity() +
  # scale_x_continuous(limits = c(0, 1)) +
  labs(
    x = "Dominant wavelength (nm)"
  ) +
  theme(
    panel.background = element_blank(),
    axis.title.y = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  ) +
  facet_wrap(~count_grp, scales = "free", ncol = 1)

all_lake_color_grouped_hue = combined_grped %>% 
  filter(metric == "Mode(Hue)") %>%  
  ggplot(aes(value, density)) + 
  geom_segment(aes(xend = value, yend = 0, color = rgb_color), alpha = 1) + 
  geom_line(lwd = 1) + 
  scale_color_identity() +
  # scale_x_continuous(limits = c(0, 1)) +
  labs(
    x = "Hue (0-1)"
  ) +
  theme(
    panel.background = element_blank(),
    axis.title.y = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  ) +
  facet_wrap(~count_grp, scales = "free", ncol = 1)

require(patchwork)

all_lake_color_grouped = all_lake_color_grouped_dw - all_lake_color_grouped_hue + plot_annotation(title = "Lake color distribution", tag_prefix = "A") +
  plot_layout(ncol = 2)

all_lake_color_grouped %>% ggsave(filename = paste0("figs/all_lake_color_grouped_", version, ".png"),
                                  width = 6,
                                  height = 8)
# ## maps
# 
# colorPalette = datFil %>% pull(hue_mode)
# 
# datFil_sf = datFil %>% 
#   st_as_sf(coords = c("clon", "clat"), crs = 4326)
# 
# ## this function calculate x and y limits under given new crs
# calculate_map_bounds = function(minlat, maxlat, minlon, maxlon, crs) {
#   line1 = st_linestring(x = matrix(c(minlon, minlat, maxlon, maxlat), byrow = T, nrow = 2), dim = "XY")
#   line2 = st_linestring(x = matrix(c(minlon, maxlat, maxlon, minlat), byrow = T, nrow = 2), dim = "XY")
#   output = st_as_sfc(list(line1, line2), crs = 4326) %>% st_transform(crs) %>% st_bbox
#   
#   return(output)
# }
# 
# xylim = calculate_map_bounds(minlat = -50, maxlat = 80, minlon = -180, maxlon = 180, crs = 54030) ## say you want to plot 40N and above with polar projection EPSG:3995
# 
# # rnaturalearthdata is a package in R that contains world map data, good for map background
# world = rnaturalearthdata::countries50 %>% st_as_sf %>% 
#   st_transform(crs = 54030)
# 
# map_mode = datFil_sf %>% ## replace lakes as your own input of the shp file. you can import shp file using st_read()
#   st_transform(crs = 54030) %>% 
#   mutate(plotColor = hsv(hue_mode, s = 1, v = 0.8)) %>% 
#   # sample_n(2000) %>% 
#   ggplot() +
#   geom_sf(data = world, fill = "black", color = NA) +
#   geom_sf(aes(color = plotColor), size = .1, alpha = 0.6) +
#   coord_sf(crs = st_crs(54030),
#            xlim = c(xylim[1], xylim[3]),
#            ylim = c(xylim[2], xylim[4]),
#            expand = T) +
#   labs(size = "Number of instances",
#        color = "") +
#   scale_color_identity() +
#   theme(panel.grid.major = element_line(color = "white", size = 0.5),
#         axis.text.y = element_blank(),
#         axis.text.x = element_blank(),
#         line = element_blank(),
#         rect = element_blank(),
#         text = element_text(size = 14),
#         panel.grid = element_blank(),
#         legend.position = c(0.125, 0.15),
#         axis.title = element_blank())
# 
# # map_mode
# 
# map_mode %>% ggsave(filename = "figs/lake_mode_color_map.png", width = 10, height = 5, dpi = 300)
# 
# 
# map_stdDev = datFil_sf %>% ## replace lakes as your own input of the shp file. you can import shp file using st_read()
#   st_transform(crs = 54030) %>% 
#   # sample_n(2000) %>%
#   ggplot() +
#   geom_sf(data = world, fill = "black", color = NA) +
#   geom_sf(aes(color = hue_stdDev), size = .1, alpha = 0.5) +
#   coord_sf(crs = st_crs(54030),
#            xlim = c(xylim[1], xylim[3]),
#            ylim = c(xylim[2], xylim[4]),
#            expand = T) +
#   labs(size = "Number of instances",
#        color = "") +
#   scale_color_viridis_c(begin = 0.2) +
#   theme(panel.grid.major = element_line(color = "white", size = 0.5),
#         axis.text.y = element_blank(),
#         axis.text.x = element_blank(),
#         line = element_blank(),
#         rect = element_blank(),
#         text = element_text(size = 14),
#         panel.grid = element_blank(),
#         legend.position = c(0.125, 0.15),
#         axis.title = element_blank())
# 
# # map_stdDev
# 
# map_stdDev %>% 
#   ggsave(filename = "figs/lake_color_stdDev_map.png", width = 10, height = 5, dpi = 300)
```

```{r}
## relation with size and dist2Shore plot
dw_palette = heuristic.wlnm2RGB_modified(seq(380, 700, by = 1), Gamma = 2.2) %>% pull(color)

datFil %>% 
  # sample_n(5000) %>%
  ggplot() +
  geom_point(aes(x = as.numeric(area) / 1e6, y = dist2Shore, color = dw_mode), size = 0.3, alpha = 0.5) +
  scale_color_gradientn(colors = dw_palette, limits = c(380, 700)) +
  scale_x_log10() +
  scale_y_log10()

require(gganimate)
datFil %>% 
  mutate(dist_grp = cut(dist2Shore, breaks = quantile(datFil$dist2Shore, probs = seq(0, 1, length.out = 20)), include.lowest = T, ordered_result = T)) %>% 
  ggplot() +
  geom_density(aes(dw_mode, fill = dist_grp), alpha = 0.4)

# +
#   transition_time(time = as.integer(dist_grp)) +
#   ease_aes("linear")
```

### Maps
```{r}
colorPalette = datFil %>% pull(hue_mode)

datFil_sf = datFil %>% 
  st_as_sf(coords = c("clon", "clat"), crs = 4326)

## this function calculate x and y limits under given new crs
calculate_map_bounds = function(minlat, maxlat, minlon, maxlon, crs) {
  line1 = st_linestring(x = matrix(c(minlon, minlat, maxlon, maxlat), byrow = T, nrow = 2), dim = "XY")
  line2 = st_linestring(x = matrix(c(minlon, maxlat, maxlon, minlat), byrow = T, nrow = 2), dim = "XY")
  output = st_as_sfc(list(line1, line2), crs = 4326) %>% st_transform(crs) %>% st_bbox
  
  return(output)
}

xylim = calculate_map_bounds(minlat = -50, maxlat = 80, minlon = -180, maxlon = 180, crs = 54030) ## say you want to plot 40N and above with polar projection EPSG:3995

# rnaturalearthdata is a package in R that contains world map data, good for map background
world = rnaturalearthdata::countries50 %>% st_as_sf %>% 
  st_transform(crs = 54030)

map_mode = datFil_sf %>% ## replace lakes as your own input of the shp file. you can import shp file using st_read()
  st_transform(crs = 54030) %>% 
  mutate(plotColor = hsv(hue_mode, s = 1, v = 0.8)) %>% 
  # sample_n(2000) %>% 
  ggplot() +
  geom_sf(data = world, fill = "black", color = NA) +
  geom_sf(aes(color = plotColor), size = .1, alpha = 0.6) +
  coord_sf(crs = st_crs(54030),
           xlim = c(xylim[1], xylim[3]),
           ylim = c(xylim[2], xylim[4]),
           expand = T) +
  labs(size = "Number of instances",
       color = "") +
  scale_color_identity() +
  theme(panel.grid.major = element_line(color = "white", size = 0.5),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
        line = element_blank(),
        rect = element_blank(),
        text = element_text(size = 14),
        panel.grid = element_blank(),
        legend.position = c(0.125, 0.15),
        axis.title = element_blank())

# map_mode

map_mode %>% ggsave(filename = "figs/lake_mode_color_map.png", width = 10, height = 5, dpi = 300)


map_stdDev = datFil_sf %>% ## replace lakes as your own input of the shp file. you can import shp file using st_read()
  st_transform(crs = 54030) %>% 
  # sample_n(2000) %>%
  ggplot() +
  geom_sf(data = world, fill = "black", color = NA) +
  geom_sf(aes(color = hue_stdDev), size = .1, alpha = 0.5) +
  coord_sf(crs = st_crs(54030),
           xlim = c(xylim[1], xylim[3]),
           ylim = c(xylim[2], xylim[4]),
           expand = T) +
  labs(size = "Number of instances",
       color = "") +
  scale_color_viridis_c(begin = 0.2) +
  theme(panel.grid.major = element_line(color = "white", size = 0.5),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
        line = element_blank(),
        rect = element_blank(),
        text = element_text(size = 14),
        panel.grid = element_blank(),
        legend.position = c(0.125, 0.15),
        axis.title = element_blank())

# map_stdDev

map_stdDev %>% 
  ggsave(filename = "figs/lake_color_stdDev_map.png", width = 10, height = 5, dpi = 300)
```


## estimate color in sRGB from wavelength
```{r}
require(colorscience)

## xyz to srgb
# XYZtoRGB: ColorSystem = c(xr, yr, xg, yg, xb, yb, xw, yw)
# for sRGB: c(0.64, 0.33, 0.3, 0.6, 0.15, 0.06, 0.31271, 0.32902)
# https://en.wikipedia.org/wiki/Color_spaces_with_RGB_primaries#Specifications
# https://en.wikipedia.org/wiki/Standard_illuminant#Illuminants_B_and_C
dw = seq(380, 700, by = 1)
ciexyz31 = ciexyz31 %>% as_tibble() ## color matching function 1931
ciexyz31 %>% gather(key = "key", value = "value", c(xbar, ybar, zbar)) %>% ggplot() + geom_line(aes(x = wlnm, y = value, color = key))

srgb = dw %>% colorscience::wlnm2xyz() %>% matrix(ncol = 3) %>% 
  as_tibble() %>% 
  bind_cols(dw = dw) %>% 
  group_by(dw) %>% 
  do({
    dat = .
    XYZtoRGB(xc = dat$V1[1], yc = dat$V2[1], zc = dat$V3[1], ColorSystem = c(0.64, 0.33, 0.3, 0.6, 0.15, 0.06, 0.31271, 0.32902)) %>% as_tibble()
    }) %>% 
  ungroup() %>% 
  filter(R >= 0 & R <= 1, G >= 0 & G <= 1, B >= 0 & B <= 1) %>% 
  mutate(srgb = rgb(R, G, B, maxColorValue = 1))
      

chromaticity.diagram.color.fill()
points(xyz[, 1], xyz[, 2], cex = 0.1)
```


## Export to GEE for visual
```{r}
## match lakes on GEE
# https://code.earthengine.google.com/b57057860f122f37a80545dcff7bf8d2
output = datOut %>% 
  select(id, hue_mode, hue_stdDev, dw_mode, dw_stdDev, dist2ShoreDp, dw.pv, dw.mode, dwLehmann.mode, dwLehmann.pv, hue.pv, hue.mode, dw_count) %>% 
  na.omit()

write_csv(output, path = paste0("outputs/mode_color_dw_",  version, ".csv"))


# ## upload the color w/ lake polygons
# lakes = st_read("outputs/lake_samples_jida_05172020.shp")
# lakes = lakes %>% select(id)
# output_sf = dat %>% 
#   select(hue_mode, hue_stdDev, hue_count, id) %>% 
#   mutate(color = hsv(h = hue_mode, s = 1, v = 1)) %>% 
#   left_join(lakes, by = "id") %>% 
#   st_as_sf()
#   
# 
# output_sf %>% names()
# st_write(output_sf, dsn = "outputs/output_sf.shp")
```

## color relationship to depth

```{r}
datColor = read_csv(paste0("outputs/mode_color_dw_",  version, ".csv"))
datLakeMeta = read_csv("outputs/lake_meta_v2.csv", col_types = "nccnnc")

merged = datColor %>% 
  left_join(datLakeMeta, by = "id") %>% 
  mutate(class = factor(class, levels = c(1:5, NA), labels = c("Endorheic Saline", "Endorheic Fresh", "Exorheic Saline", "Exorheic Fresh", "Lagoon", "Reservoir"), ordered = T, exclude = NULL))

merged %>% 
  # sample_n(1000) %>% 
  filter(!is.na(depthMean)) %>% 
  mutate(depthGrp = cut(depthMean, breaks = quantile(x = depthMean, probs = seq(0, 1, by = 0.2)), include.lowest = T)) %>% 
  ggplot() +
  geom_density(aes(x = dw.mode, color = depthGrp), alpha = 0.3) +
  facet_wrap(~class) +
  labs(color = "Depth group",
       x = "Dominant wavelength (nm)",
       y = "")

merged %>% group_by(class) %>% count() %>% ungroup
```


## approx rgb from wavelength for visualization in GEE

```{r}
# method1
colorscience::heuristic.wlnm2RGB(wavelength = seq(380, 700, length.out = 100)) %>% as_tibble() %>% 
  mutate(color_rgb = as.character(rgb(red = R, green = G, blue = B, maxColorValue = 1))) %>% 
  pull(color_rgb) %>% 
  paste0(collapse = "', '")

#method2
dw2rgb = function(w) {
  if (w >= 380 & w < 440) {
    R = -(w - 440.) / (440. - 380.)
    G = 0.0
    B = 1.0
  } else if (w >= 440 & w < 490) {
    R = 0.0
    G = (w - 440.) / (490. - 440.)
    B = 1.0
  } else if (w >= 490 & w < 510) {
    R = 0.0
    G = 1.0
    B = -(w - 510.) / (510. - 490.)
  } else if (w >= 510 & w < 580) {
    R = (w - 510.) / (580. - 510.)
    G = 1.0
    B = 0.0
  } else if (w >= 580 & w < 645) {
    R = 1.0
    G = -(w - 645.) / (645. - 580.)
    B = 0.0
  } else if (w >= 645 & w <= 780) {
    R = 1.0
    G = 0.0
    B = 0.0
  } else {
    R = 0.0
    G = 0.0
    B = 0.0
  }
        
  # return(rgb(R, G, B, maxColorValue = 1))
  return(tibble(R, G, B, rgb = rgb(R, G, B, maxColorValue = 1)))
}

tibble(w = seq(380, 700, length.out = 100)) %>% 
  group_by(w) %>% 
  do({dw2rgb(.$w[1])}) %>% 
  ungroup() %>% 
  pull(rgb) %>% 
  paste0(collapse = "', '")
## implement this in GEE lookup table method
# https://code.earthengine.google.com/c44243894ad2c9b0f891e4adee121e62

## method 3 modify the existing function
wl = 380:700
test_color = tibble(wl = wl) %>% 
  bind_cols(heuristic.wlnm2RGB_modified(wl, Gamma = 0.8, IntensityMax = 1))

ggplot(data = test_color) + geom_point(aes(x = wl, y = 1, color = wl)) +
  scale_color_gradientn(colors = test_color$color, limits = c(380, 700))
```


## compare hue and dw

```{r}
dw = 557
hue = 0.26

plot(c(-2, 2), c(0, 0), xlim = c(-10, 10))
points(-2, 0, col = hsv(hue, 1, 1), cex = 10, pch = 20)
points(2, 0, col = heuristic.wlnm2RGB_modified(dw)$color[1], cex = 10, pch = 20)
```

